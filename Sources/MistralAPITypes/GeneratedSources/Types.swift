// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Create Transcription
    ///
    /// - Remark: HTTP `POST /v1/audio/transcriptions`.
    /// - Remark: Generated from `#/paths//v1/audio/transcriptions/post(audio_api_v1_transcriptions_post)`.
    func audio_api_v1_transcriptions_post(_ input: Operations.audio_api_v1_transcriptions_post.Input) async throws -> Operations.audio_api_v1_transcriptions_post.Output
    /// Create streaming transcription (SSE)
    ///
    /// - Remark: HTTP `POST /v1/audio/transcriptions#stream`.
    /// - Remark: Generated from `#/paths//v1/audio/transcriptions#stream/post(audio_api_v1_transcriptions_post_stream)`.
    func audio_api_v1_transcriptions_post_stream(_ input: Operations.audio_api_v1_transcriptions_post_stream.Input) async throws -> Operations.audio_api_v1_transcriptions_post_stream.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Create Transcription
    ///
    /// - Remark: HTTP `POST /v1/audio/transcriptions`.
    /// - Remark: Generated from `#/paths//v1/audio/transcriptions/post(audio_api_v1_transcriptions_post)`.
    public func audio_api_v1_transcriptions_post(
        headers: Operations.audio_api_v1_transcriptions_post.Input.Headers = .init(),
        body: Operations.audio_api_v1_transcriptions_post.Input.Body
    ) async throws -> Operations.audio_api_v1_transcriptions_post.Output {
        try await audio_api_v1_transcriptions_post(Operations.audio_api_v1_transcriptions_post.Input(
            headers: headers,
            body: body
        ))
    }
    /// Create streaming transcription (SSE)
    ///
    /// - Remark: HTTP `POST /v1/audio/transcriptions#stream`.
    /// - Remark: Generated from `#/paths//v1/audio/transcriptions#stream/post(audio_api_v1_transcriptions_post_stream)`.
    public func audio_api_v1_transcriptions_post_stream(
        headers: Operations.audio_api_v1_transcriptions_post_stream.Input.Headers = .init(),
        body: Operations.audio_api_v1_transcriptions_post_stream.Input.Body
    ) async throws -> Operations.audio_api_v1_transcriptions_post_stream.Output {
        try await audio_api_v1_transcriptions_post_stream(Operations.audio_api_v1_transcriptions_post_stream.Input(
            headers: headers,
            body: body
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    /// Production server
    public enum Server1 {
        /// Production server
        public static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "https://api.mistral.ai",
                variables: []
            )
        }
    }
    /// Production server
    @available(*, deprecated, renamed: "Servers.Server1.url")
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "https://api.mistral.ai",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// - Remark: Generated from `#/components/schemas/TranscriptionResponse`.
        public struct TranscriptionResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptionResponse/model`.
            public var model: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptionResponse/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptionResponse/segments`.
            public var segments: [Components.Schemas.TranscriptionSegmentChunk]?
            /// - Remark: Generated from `#/components/schemas/TranscriptionResponse/usage`.
            public var usage: Components.Schemas.UsageInfo
            /// Creates a new `TranscriptionResponse`.
            ///
            /// - Parameters:
            ///   - model:
            ///   - text:
            ///   - segments:
            ///   - usage:
            public init(
                model: Swift.String,
                text: Swift.String,
                segments: [Components.Schemas.TranscriptionSegmentChunk]? = nil,
                usage: Components.Schemas.UsageInfo
            ) {
                self.model = model
                self.text = text
                self.segments = segments
                self.usage = usage
            }
            public enum CodingKeys: String, CodingKey {
                case model
                case text
                case segments
                case usage
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.model = try container.decode(
                    Swift.String.self,
                    forKey: .model
                )
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.segments = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptionSegmentChunk].self,
                    forKey: .segments
                )
                self.usage = try container.decode(
                    Components.Schemas.UsageInfo.self,
                    forKey: .usage
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "model",
                    "text",
                    "segments",
                    "usage"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionSegmentChunk`.
        public struct TranscriptionSegmentChunk: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegmentChunk/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegmentChunk/start`.
            public var start: Swift.Double
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegmentChunk/end`.
            public var end: Swift.Double
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegmentChunk/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case transcription_segment = "transcription_segment"
            }
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegmentChunk/type`.
            public var _type: Components.Schemas.TranscriptionSegmentChunk._typePayload?
            /// Creates a new `TranscriptionSegmentChunk`.
            ///
            /// - Parameters:
            ///   - text:
            ///   - start:
            ///   - end:
            ///   - _type:
            public init(
                text: Swift.String,
                start: Swift.Double,
                end: Swift.Double,
                _type: Components.Schemas.TranscriptionSegmentChunk._typePayload? = nil
            ) {
                self.text = text
                self.start = start
                self.end = end
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
                case _type = "type"
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.start = try container.decode(
                    Swift.Double.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Double.self,
                    forKey: .end
                )
                self._type = try container.decodeIfPresent(
                    Components.Schemas.TranscriptionSegmentChunk._typePayload.self,
                    forKey: ._type
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "start",
                    "end",
                    "type"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/UsageInfo`.
        public struct UsageInfo: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/UsageInfo/prompt_tokens`.
            public var prompt_tokens: Swift.Int
            /// - Remark: Generated from `#/components/schemas/UsageInfo/completion_tokens`.
            public var completion_tokens: Swift.Int
            /// - Remark: Generated from `#/components/schemas/UsageInfo/total_tokens`.
            public var total_tokens: Swift.Int
            /// Creates a new `UsageInfo`.
            ///
            /// - Parameters:
            ///   - prompt_tokens:
            ///   - completion_tokens:
            ///   - total_tokens:
            public init(
                prompt_tokens: Swift.Int,
                completion_tokens: Swift.Int,
                total_tokens: Swift.Int
            ) {
                self.prompt_tokens = prompt_tokens
                self.completion_tokens = completion_tokens
                self.total_tokens = total_tokens
            }
            public enum CodingKeys: String, CodingKey {
                case prompt_tokens
                case completion_tokens
                case total_tokens
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.prompt_tokens = try container.decode(
                    Swift.Int.self,
                    forKey: .prompt_tokens
                )
                self.completion_tokens = try container.decode(
                    Swift.Int.self,
                    forKey: .completion_tokens
                )
                self.total_tokens = try container.decode(
                    Swift.Int.self,
                    forKey: .total_tokens
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "prompt_tokens",
                    "completion_tokens",
                    "total_tokens"
                ])
            }
        }
        /// The File object (not file name) to be uploaded.
        ///  To upload a file and specify a custom file name you should format your request as such:
        ///  ```bash
        ///  file=@path/to/your/file.jsonl;filename=custom_name.jsonl
        ///  ```
        ///  Otherwise, you can just keep the original file name:
        ///  ```bash
        ///  file=@path/to/your/file.jsonl
        ///  ```
        ///
        /// - Remark: Generated from `#/components/schemas/File`.
        public typealias File = Swift.String
        /// - Remark: Generated from `#/components/schemas/TimestampGranularity`.
        @frozen public enum TimestampGranularity: String, Codable, Hashable, Sendable, CaseIterable {
            case segment = "segment"
        }
        /// - Remark: Generated from `#/components/schemas/AudioTranscriptionRequest`.
        @frozen public enum AudioTranscriptionRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/schemas/AudioTranscriptionRequest/model`.
            public struct modelPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `modelPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case model(OpenAPIRuntime.MultipartPart<Components.Schemas.AudioTranscriptionRequest.modelPayload>)
            /// - Remark: Generated from `#/components/schemas/AudioTranscriptionRequest/stream`.
            public struct streamPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `streamPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case stream(OpenAPIRuntime.MultipartPart<Components.Schemas.AudioTranscriptionRequest.streamPayload>)
            /// - Remark: Generated from `#/components/schemas/AudioTranscriptionRequest/timestamp_granularities`.
            public struct timestamp_granularitiesPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `timestamp_granularitiesPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case timestamp_granularities(OpenAPIRuntime.MultipartPart<Components.Schemas.AudioTranscriptionRequest.timestamp_granularitiesPayload>)
            case undocumented(OpenAPIRuntime.MultipartRawPart)
        }
        /// - Remark: Generated from `#/components/schemas/AudioTranscriptionRequestStream`.
        @frozen public enum AudioTranscriptionRequestStream: Sendable, Hashable {
            /// - Remark: Generated from `#/components/schemas/AudioTranscriptionRequestStream/model`.
            public struct modelPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `modelPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case model(OpenAPIRuntime.MultipartPart<Components.Schemas.AudioTranscriptionRequestStream.modelPayload>)
            /// - Remark: Generated from `#/components/schemas/AudioTranscriptionRequestStream/stream`.
            public struct streamPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `streamPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case stream(OpenAPIRuntime.MultipartPart<Components.Schemas.AudioTranscriptionRequestStream.streamPayload>)
            /// - Remark: Generated from `#/components/schemas/AudioTranscriptionRequestStream/timestamp_granularities`.
            public struct timestamp_granularitiesPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `timestamp_granularitiesPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case timestamp_granularities(OpenAPIRuntime.MultipartPart<Components.Schemas.AudioTranscriptionRequestStream.timestamp_granularitiesPayload>)
            case undocumented(OpenAPIRuntime.MultipartRawPart)
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionStreamLanguage`.
        public struct TranscriptionStreamLanguage: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamLanguage/audio_language`.
            public var audio_language: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamLanguage/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case transcription_period_language = "transcription.language"
            }
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamLanguage/type`.
            public var _type: Components.Schemas.TranscriptionStreamLanguage._typePayload?
            /// Creates a new `TranscriptionStreamLanguage`.
            ///
            /// - Parameters:
            ///   - audio_language:
            ///   - _type:
            public init(
                audio_language: Swift.String,
                _type: Components.Schemas.TranscriptionStreamLanguage._typePayload? = nil
            ) {
                self.audio_language = audio_language
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case audio_language
                case _type = "type"
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.audio_language = try container.decode(
                    Swift.String.self,
                    forKey: .audio_language
                )
                self._type = try container.decodeIfPresent(
                    Components.Schemas.TranscriptionStreamLanguage._typePayload.self,
                    forKey: ._type
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "audio_language",
                    "type"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionStreamSegmentDelta`.
        public struct TranscriptionStreamSegmentDelta: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamSegmentDelta/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamSegmentDelta/start`.
            public var start: Swift.Double
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamSegmentDelta/end`.
            public var end: Swift.Double
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamSegmentDelta/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case transcription_period_segment = "transcription.segment"
            }
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamSegmentDelta/type`.
            public var _type: Components.Schemas.TranscriptionStreamSegmentDelta._typePayload?
            /// Creates a new `TranscriptionStreamSegmentDelta`.
            ///
            /// - Parameters:
            ///   - text:
            ///   - start:
            ///   - end:
            ///   - _type:
            public init(
                text: Swift.String,
                start: Swift.Double,
                end: Swift.Double,
                _type: Components.Schemas.TranscriptionStreamSegmentDelta._typePayload? = nil
            ) {
                self.text = text
                self.start = start
                self.end = end
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
                case _type = "type"
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.start = try container.decode(
                    Swift.Double.self,
                    forKey: .start
                )
                self.end = try container.decode(
                    Swift.Double.self,
                    forKey: .end
                )
                self._type = try container.decodeIfPresent(
                    Components.Schemas.TranscriptionStreamSegmentDelta._typePayload.self,
                    forKey: ._type
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "start",
                    "end",
                    "type"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionStreamTextDelta`.
        public struct TranscriptionStreamTextDelta: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamTextDelta/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamTextDelta/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case transcription_period_text_period_delta = "transcription.text.delta"
            }
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamTextDelta/type`.
            public var _type: Components.Schemas.TranscriptionStreamTextDelta._typePayload?
            /// Creates a new `TranscriptionStreamTextDelta`.
            ///
            /// - Parameters:
            ///   - text:
            ///   - _type:
            public init(
                text: Swift.String,
                _type: Components.Schemas.TranscriptionStreamTextDelta._typePayload? = nil
            ) {
                self.text = text
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case _type = "type"
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self._type = try container.decodeIfPresent(
                    Components.Schemas.TranscriptionStreamTextDelta._typePayload.self,
                    forKey: ._type
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "text",
                    "type"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionStreamDone`.
        public struct TranscriptionStreamDone: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamDone/model`.
            public var model: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamDone/text`.
            public var text: Swift.String
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamDone/segments`.
            public var segments: [Components.Schemas.TranscriptionSegmentChunk]?
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamDone/usage`.
            public var usage: Components.Schemas.UsageInfo
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamDone/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case transcription_period_done = "transcription.done"
            }
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamDone/type`.
            public var _type: Components.Schemas.TranscriptionStreamDone._typePayload?
            /// Creates a new `TranscriptionStreamDone`.
            ///
            /// - Parameters:
            ///   - model:
            ///   - text:
            ///   - segments:
            ///   - usage:
            ///   - _type:
            public init(
                model: Swift.String,
                text: Swift.String,
                segments: [Components.Schemas.TranscriptionSegmentChunk]? = nil,
                usage: Components.Schemas.UsageInfo,
                _type: Components.Schemas.TranscriptionStreamDone._typePayload? = nil
            ) {
                self.model = model
                self.text = text
                self.segments = segments
                self.usage = usage
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case model
                case text
                case segments
                case usage
                case _type = "type"
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.model = try container.decode(
                    Swift.String.self,
                    forKey: .model
                )
                self.text = try container.decode(
                    Swift.String.self,
                    forKey: .text
                )
                self.segments = try container.decodeIfPresent(
                    [Components.Schemas.TranscriptionSegmentChunk].self,
                    forKey: .segments
                )
                self.usage = try container.decode(
                    Components.Schemas.UsageInfo.self,
                    forKey: .usage
                )
                self._type = try container.decodeIfPresent(
                    Components.Schemas.TranscriptionStreamDone._typePayload.self,
                    forKey: ._type
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "model",
                    "text",
                    "segments",
                    "usage",
                    "type"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEvents`.
        public struct TranscriptionStreamEvents: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEvents/event`.
            public var event: Components.Schemas.TranscriptionStreamEventTypes
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEvents/data`.
            @frozen public enum dataPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEvents/data/TranscriptionStreamDone`.
                case transcription_period_done(Components.Schemas.TranscriptionStreamDone)
                /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEvents/data/TranscriptionStreamLanguage`.
                case transcription_period_language(Components.Schemas.TranscriptionStreamLanguage)
                /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEvents/data/TranscriptionStreamSegmentDelta`.
                case transcription_period_segment(Components.Schemas.TranscriptionStreamSegmentDelta)
                /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEvents/data/TranscriptionStreamTextDelta`.
                case transcription_period_text_period_delta(Components.Schemas.TranscriptionStreamTextDelta)
                public enum CodingKeys: String, CodingKey {
                    case _type = "type"
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    let discriminator = try container.decode(
                        Swift.String.self,
                        forKey: ._type
                    )
                    switch discriminator {
                    case "transcription.done":
                        self = .transcription_period_done(try .init(from: decoder))
                    case "transcription.language":
                        self = .transcription_period_language(try .init(from: decoder))
                    case "transcription.segment":
                        self = .transcription_period_segment(try .init(from: decoder))
                    case "transcription.text.delta":
                        self = .transcription_period_text_period_delta(try .init(from: decoder))
                    default:
                        throw Swift.DecodingError.unknownOneOfDiscriminator(
                            discriminatorKey: CodingKeys._type,
                            discriminatorValue: discriminator,
                            codingPath: decoder.codingPath
                        )
                    }
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .transcription_period_done(value):
                        try value.encode(to: encoder)
                    case let .transcription_period_language(value):
                        try value.encode(to: encoder)
                    case let .transcription_period_segment(value):
                        try value.encode(to: encoder)
                    case let .transcription_period_text_period_delta(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEvents/data`.
            public var data: Components.Schemas.TranscriptionStreamEvents.dataPayload
            /// Creates a new `TranscriptionStreamEvents`.
            ///
            /// - Parameters:
            ///   - event:
            ///   - data:
            public init(
                event: Components.Schemas.TranscriptionStreamEventTypes,
                data: Components.Schemas.TranscriptionStreamEvents.dataPayload
            ) {
                self.event = event
                self.data = data
            }
            public enum CodingKeys: String, CodingKey {
                case event
                case data
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.event = try container.decode(
                    Components.Schemas.TranscriptionStreamEventTypes.self,
                    forKey: .event
                )
                self.data = try container.decode(
                    Components.Schemas.TranscriptionStreamEvents.dataPayload.self,
                    forKey: .data
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "event",
                    "data"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TranscriptionStreamEventTypes`.
        @frozen public enum TranscriptionStreamEventTypes: String, Codable, Hashable, Sendable, CaseIterable {
            case transcription_period_language = "transcription.language"
            case transcription_period_segment = "transcription.segment"
            case transcription_period_text_period_delta = "transcription.text.delta"
            case transcription_period_done = "transcription.done"
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {}
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {}
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Create Transcription
    ///
    /// - Remark: HTTP `POST /v1/audio/transcriptions`.
    /// - Remark: Generated from `#/paths//v1/audio/transcriptions/post(audio_api_v1_transcriptions_post)`.
    public enum audio_api_v1_transcriptions_post {
        public static let id: Swift.String = "audio_api_v1_transcriptions_post"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1/audio/transcriptions/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.audio_api_v1_transcriptions_post.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.audio_api_v1_transcriptions_post.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.audio_api_v1_transcriptions_post.Input.Headers
            /// - Remark: Generated from `#/paths/v1/audio/transcriptions/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1/audio/transcriptions/POST/requestBody/content/multipart\/form-data`.
                case multipartForm(OpenAPIRuntime.MultipartBody<Components.Schemas.AudioTranscriptionRequest>)
            }
            public var body: Operations.audio_api_v1_transcriptions_post.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.audio_api_v1_transcriptions_post.Input.Headers = .init(),
                body: Operations.audio_api_v1_transcriptions_post.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1/audio/transcriptions/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1/audio/transcriptions/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.TranscriptionResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TranscriptionResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.audio_api_v1_transcriptions_post.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.audio_api_v1_transcriptions_post.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Successful Response
            ///
            /// - Remark: Generated from `#/paths//v1/audio/transcriptions/post(audio_api_v1_transcriptions_post)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.audio_api_v1_transcriptions_post.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.audio_api_v1_transcriptions_post.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create streaming transcription (SSE)
    ///
    /// - Remark: HTTP `POST /v1/audio/transcriptions#stream`.
    /// - Remark: Generated from `#/paths//v1/audio/transcriptions#stream/post(audio_api_v1_transcriptions_post_stream)`.
    public enum audio_api_v1_transcriptions_post_stream {
        public static let id: Swift.String = "audio_api_v1_transcriptions_post_stream"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1/audio/transcriptions#stream/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.audio_api_v1_transcriptions_post_stream.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.audio_api_v1_transcriptions_post_stream.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.audio_api_v1_transcriptions_post_stream.Input.Headers
            /// - Remark: Generated from `#/paths/v1/audio/transcriptions#stream/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1/audio/transcriptions#stream/POST/requestBody/content/multipart\/form-data`.
                case multipartForm(OpenAPIRuntime.MultipartBody<Components.Schemas.AudioTranscriptionRequestStream>)
            }
            public var body: Operations.audio_api_v1_transcriptions_post_stream.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.audio_api_v1_transcriptions_post_stream.Input.Headers = .init(),
                body: Operations.audio_api_v1_transcriptions_post_stream.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1/audio/transcriptions#stream/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1/audio/transcriptions#stream/POST/responses/200/content/text\/event-stream`.
                    case text_event_hyphen_stream(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.text_event_hyphen_stream`.
                    ///
                    /// - Throws: An error if `self` is not `.text_event_hyphen_stream`.
                    /// - SeeAlso: `.text_event_hyphen_stream`.
                    public var text_event_hyphen_stream: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .text_event_hyphen_stream(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.audio_api_v1_transcriptions_post_stream.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.audio_api_v1_transcriptions_post_stream.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Stream of transcription events
            ///
            /// - Remark: Generated from `#/paths//v1/audio/transcriptions#stream/post(audio_api_v1_transcriptions_post_stream)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.audio_api_v1_transcriptions_post_stream.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.audio_api_v1_transcriptions_post_stream.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case text_event_hyphen_stream
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "text/event-stream":
                    self = .text_event_hyphen_stream
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .text_event_hyphen_stream:
                    return "text/event-stream"
                }
            }
            public static var allCases: [Self] {
                [
                    .text_event_hyphen_stream
                ]
            }
        }
    }
}
